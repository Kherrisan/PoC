# CVE-2022-42905

- 应该不是 ASAN 能检测得出来的。ASAN 对于堆内存只能检测 malloc 所分配的连续内存前后的 overread 和 overwrite，而这里的 overread 发生在 ssl 结构体内部，ASAN 没法检测出来。
- 网上没有 exploit。
- 虽然确实有 heap overread，但是读到的数据马上会被覆盖掉，所以是否真的是 Maximilian 说的那样，存疑。

[seclists](https://seclists.org/fulldisclosure/2023/Jan/11)

If wolfSSL callback functions are enabled (i.e., the flag `WOLFSSL_CALLBACKS` is
enabled), then a malicious client or network attacker can send a Client Hello
message to a server that when parsed by the server will trigger a buffer
over-read on the heap of at least 5 bytes. Similarly, a malicious server or a
network attacker can send a Hello Retry Request message to a client that when
parsed by the client will trigger a buffer over-read on the heap of at least 15
bytes.

The `AddPacketInfo` is given a buffer that should be the input buffer and that
actually is shifted by 5 bytes on the left, i.e., instead of reading
`input[0]..input[length]`, the function will read `input[-5]..input[length]` and
store it in a buffer that is exposed through the wolfSSL API. Note that `input`
is stored on the heap and `input[-5]` to `input[-1]` might store sensitive data
that should not be given to `AddPacketInfo`, for example when callback functions
are used as logging facility (through the API functions `wolfSSL_accept_ex` and
`wolfSSL_connect_ex`).

This buffer over-read can be triggered at a server with a single Client Hello
message. We have confirmed this with a proof-of-concept test case given below on
wolfSSL 5.5.0, on the version from the master branch, and on version 5.4.0. A
similar buffer over-read can be triggered at a client with the same wolfSSL
versions.

```c
int DoTls13HandShakeMsg(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                        word32 totalSz) {
    GetHandshakeHeader(ssl, input, inOutIdx, &type, &size, totalSz);
    return DoTls13HandShakeMsgType(ssl, input, inOutIdx, type, size,
                                        totalSz);
}
                        
static int GetHandshakeHeader(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                              byte* type, word32* size, word32 totalSz)
{
    const byte* ptr = input + *inOutIdx;
    (void)ssl;

    *inOutIdx += HANDSHAKE_HEADER_SZ; // *inOutIdx += 4;
    if (*inOutIdx > totalSz)
        return BUFFER_E;

    *type = ptr[0];             // one-bit handshake type, like 1 for ClientHello
    *size = c24to32(&ptr[1]);   // 24-bit handshake size

    if (*size > totalSz - *inOutIdx)
        return BUFFER_E;
    c24to32(&ptr[1], size);

    return 0;
}

int DoTls13HandShakeMsgType(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                            byte type, word32 size, word32 totalSz)
{
#if defined(WOLFSSL_CALLBACKS)
    /* add name later, add on record and handshake header part back on */
    if (ssl->toInfoOn) {
        // RECORD_HEADER_SZ = 5, HANDSHAKE_HEADER_SZ = 4
        int add = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
        AddPacketInfo(ssl, 0, handshake, input + *inOutIdx - add, // input + *inOutIdx - 9 = input - 5
                        size + add, READ_PROTO, ssl->heap);
        AddLateRecordHeader(&ssl->curRL, &ssl->timeoutInfo);
    }
#endif
}
```